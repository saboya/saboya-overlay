From 5fd7aada3492731844ab08c18071a167ae73d5b2 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 25 Sep 2025 16:30:56 +0800
Subject: [PATCH 1/6] onscreen/native: Don't commit to acquiring the primary
 GPU FB late

Because we'll soon want to acquire it early for COPY_MODE_SECONDARY_GPU
---
 src/backends/native/meta-onscreen-native.c | 83 +++++++++++++---------
 1 file changed, 50 insertions(+), 33 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index a95cc72f462..4207ec38e14 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -906,15 +906,51 @@ secondary_gpu_state_free (MetaOnscreenNativeSecondaryGpuState *secondary_gpu_sta
   g_free (secondary_gpu_state);
 }
 
+static MetaDrmBuffer *
+acquire_primary_front_buffer (CoglOnscreen  *onscreen,
+                              GError       **error)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  MetaRendererNative *renderer_native = onscreen_native->renderer_native;
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer_get_winsys_data (cogl_renderer);
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaDrmBufferFlags buffer_flags;
+  MetaDrmBufferGbm *buffer_gbm;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+  MetaDeviceFile *render_device_file =
+    meta_render_device_get_device_file (render_device);
+
+  buffer_flags = META_DRM_BUFFER_FLAG_NONE;
+  if (!meta_renderer_native_use_modifiers (renderer_native))
+    buffer_flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
+
+  buffer_gbm =
+    meta_drm_buffer_gbm_new_lock_front (render_device_file,
+                                        onscreen_native->gbm.surface,
+                                        buffer_flags,
+                                        error);
+  if (!buffer_gbm)
+    return NULL;
+
+  return META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
+}
+
 static MetaDrmBuffer *
 import_shared_framebuffer (CoglOnscreen                        *onscreen,
-                           MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state,
-                           MetaDrmBuffer                       *primary_gpu_fb)
+                           MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
 {
   MetaRenderDevice *render_device;
   g_autoptr (GError) error = NULL;
+  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   MetaDrmBuffer *imported_buffer;
 
+  primary_gpu_fb = acquire_primary_front_buffer (onscreen, &error);
+  if (!primary_gpu_fb)
+    return NULL;
+
   render_device = secondary_gpu_state->renderer_gpu_data->render_device;
   imported_buffer =
     meta_render_device_import_dma_buf (render_device,
@@ -1052,7 +1088,6 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
                              MetaFrameNative                      *frame_native,
                              MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
                              MetaRendererNativeGpuData            *renderer_gpu_data,
-                             MetaDrmBuffer                        *primary_gpu_fb,
                              const MtkRegion                      *region,
                              GError                              **error)
 {
@@ -1075,10 +1110,15 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   int buffer_age = 0;
   g_autoptr (MtkRegion) blit_region = NULL;
   g_autoptr (MtkRegion) region_to_push = NULL;
+  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
 
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "copy_shared_framebuffer_gpu()");
 
+  primary_gpu_fb = acquire_primary_front_buffer (onscreen, error);
+  if (!primary_gpu_fb)
+    return NULL;
+
   if (renderer_gpu_data->secondary.needs_explicit_sync)
     sync_fd = meta_frame_native_steal_sync_fd (frame_native);
 
@@ -1480,7 +1520,6 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen    *onscreen,
 static MetaDrmBuffer *
 acquire_front_buffer (CoglOnscreen     *onscreen,
                       MetaFrameNative  *frame_native,
-                      MetaDrmBuffer    *primary_gpu_fb,
                       MetaDrmBuffer    *secondary_gpu_fb,
                       const MtkRegion  *region,
                       GError          **error)
@@ -1496,7 +1535,7 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
 
   secondary_gpu_state = onscreen_native->secondary_gpu_state;
   if (!secondary_gpu_state)
-    return g_object_ref (primary_gpu_fb);
+    return acquire_primary_front_buffer (onscreen, error);
 
   renderer_gpu_data =
     meta_renderer_native_get_gpu_data (renderer_native,
@@ -1505,8 +1544,7 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
     {
     case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
       imported_fb = import_shared_framebuffer (onscreen,
-                                               secondary_gpu_state,
-                                               primary_gpu_fb);
+                                               secondary_gpu_state);
       if (imported_fb)
         return imported_fb;
       /* The fallback was prepared in pre_swap_buffers and is currently
@@ -1528,7 +1566,6 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
                                           frame_native,
                                           secondary_gpu_state,
                                           renderer_gpu_data,
-                                          primary_gpu_fb,
                                           region,
                                           error);
     }
@@ -1643,14 +1680,10 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
-  MetaDeviceFile *render_device_file;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   CoglOnscreenClass *parent_class;
   g_autoptr (GError) error = NULL;
-  MetaDrmBufferFlags buffer_flags;
-  MetaDrmBufferGbm *buffer_gbm;
-  g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) buffer = NULL;
   g_autofd int sync_fd = -1;
@@ -1673,32 +1706,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
-  render_device_file =
-    meta_render_device_get_device_file (renderer_gpu_data->render_device);
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
-      buffer_flags = META_DRM_BUFFER_FLAG_NONE;
-      if (!meta_renderer_native_use_modifiers (renderer_native))
-        buffer_flags |= META_DRM_BUFFER_FLAG_DISABLE_MODIFIERS;
-
-      buffer_gbm =
-        meta_drm_buffer_gbm_new_lock_front (render_device_file,
-                                            onscreen_native->gbm.surface,
-                                            buffer_flags,
-                                            &error);
-      if (!buffer_gbm)
-        {
-          g_warning ("Failed to lock front buffer on %s: %s",
-                     meta_device_file_get_path (render_device_file),
-                     error->message);
-          goto swap_failed;
-        }
-
-      primary_gpu_fb = META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
       buffer = acquire_front_buffer (onscreen,
                                      frame_native,
-                                     primary_gpu_fb,
                                      secondary_gpu_fb,
                                      region,
                                      &error);
@@ -1712,6 +1724,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
       if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
         {
+          MetaRenderDevice *render_device =
+            renderer_gpu_data->render_device;
+          MetaDeviceFile *render_device_file =
+            meta_render_device_get_device_file (render_device);
+
           g_warning ("Failed to ensure KMS FB ID on %s: %s",
                      meta_device_file_get_path (render_device_file),
                      error->message);
-- 
GitLab


From 3f854a904d2ffec431e3d8793ef758002759ac87 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 2 Oct 2025 17:28:42 +0800
Subject: [PATCH 2/6] onscreen/native: Split COPY_MODE_SECONDARY_GPU in two

So that the non-blocking part starts immediately (copying between GPUs),
and the blocking part (Nvidia's lock_front_buffer) is deferred until
the sync_fd is signalled.
---
 src/backends/native/meta-onscreen-native.c | 146 ++++++++++++++-------
 1 file changed, 98 insertions(+), 48 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 4207ec38e14..30336bf582b 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -1083,13 +1083,12 @@ get_secondary_gpu_buffer_age (MetaOnscreenNativeSecondaryGpuState *secondary_gpu
   return buffer_age;
 }
 
-static MetaDrmBuffer *
-copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
-                             MetaFrameNative                      *frame_native,
-                             MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
-                             MetaRendererNativeGpuData            *renderer_gpu_data,
-                             const MtkRegion                      *region,
-                             GError                              **error)
+static int
+start_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                                   MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
+                                   MetaRendererNativeGpuData            *renderer_gpu_data,
+                                   const MtkRegion                      *region,
+                                   GError                              **error)
 {
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
@@ -1099,9 +1098,6 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
   MetaRenderDevice *render_device;
   EGLDisplay egl_display;
-  gboolean use_modifiers;
-  MetaDeviceFile *device_file;
-  MetaDrmBufferFlags flags;
   MetaDrmBufferGbm *buffer_gbm = NULL;
   struct gbm_bo *bo;
   EGLSync egl_sync = EGL_NO_SYNC;
@@ -1112,15 +1108,15 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
   g_autoptr (MtkRegion) region_to_push = NULL;
   g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
 
-  COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
-                           "copy_shared_framebuffer_gpu()");
+  COGL_TRACE_BEGIN_SCOPED (StartCopySharedFramebufferSecondaryGpu,
+                           "start_copy_shared_framebuffer_gpu()");
 
   primary_gpu_fb = acquire_primary_front_buffer (onscreen, error);
   if (!primary_gpu_fb)
-    return NULL;
+    return -1;
 
   if (renderer_gpu_data->secondary.needs_explicit_sync)
-    sync_fd = meta_frame_native_steal_sync_fd (frame_native);
+    sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
 
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
@@ -1212,7 +1208,39 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
       goto done;
     }
 
-  meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+done:
+  if (egl_sync != EGL_NO_SYNC)
+    {
+      g_autoptr (GError) local_error = NULL;
+
+      if (!meta_egl_destroy_sync (egl,
+                                  egl_display,
+                                  egl_sync,
+                                  &local_error))
+        g_warning ("Failed to destroy secondary GPU EGLSync: %s", local_error->message);
+    }
+
+  _cogl_winsys_egl_ensure_current (cogl_display);
+
+  return g_steal_fd (&sync_fd);
+}
+
+static MetaDrmBuffer *
+finish_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                                    MetaFrameNative                      *frame_native,
+                                    MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
+                                    MetaRendererNativeGpuData            *renderer_gpu_data,
+                                    GError                              **error)
+{
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderDevice *render_device = renderer_gpu_data->render_device;
+  gboolean use_modifiers;
+  MetaDeviceFile *device_file;
+  MetaDrmBufferFlags flags;
+  MetaDrmBufferGbm *buffer_gbm = NULL;
+
+  COGL_TRACE_BEGIN_SCOPED (FinishCopySharedFramebufferSecondaryGpu,
+                           "finish_copy_shared_framebuffer_gpu()");
 
   use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
   device_file = meta_render_device_get_device_file (render_device);
@@ -1227,29 +1255,7 @@ copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
                                         flags,
                                         error);
   if (!buffer_gbm)
-    {
-      g_prefix_error (error, "meta_drm_buffer_gbm_new_lock_front failed: ");
-      goto done;
-    }
-
-  g_object_set_qdata_full (G_OBJECT (buffer_gbm),
-                           blit_source_quark,
-                           g_object_ref (primary_gpu_fb),
-                           g_object_unref);
-
-done:
-  if (egl_sync != EGL_NO_SYNC)
-    {
-      g_autoptr (GError) local_error = NULL;
-
-      if (!meta_egl_destroy_sync (egl,
-                                  egl_display,
-                                  egl_sync,
-                                  &local_error))
-        g_warning ("Failed to destroy secondary GPU EGLSync: %s", local_error->message);
-    }
-
-  _cogl_winsys_egl_ensure_current (cogl_display);
+    g_prefix_error (error, "meta_drm_buffer_gbm_new_lock_front failed: ");
 
   return buffer_gbm ? META_DRM_BUFFER (buffer_gbm) : NULL;
 }
@@ -1517,11 +1523,50 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen    *onscreen,
   return copy;
 }
 
+static int
+update_state_post_swap_buffers (CoglOnscreen     *onscreen,
+                                const MtkRegion  *region,
+                                GError          **error)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+  g_autofd int sync_fd = -1;
+
+  secondary_gpu_state = onscreen_native->secondary_gpu_state;
+  if (secondary_gpu_state)
+    {
+      MetaRendererNativeGpuData *renderer_gpu_data;
+
+      renderer_gpu_data = secondary_gpu_state->renderer_gpu_data;
+      switch (renderer_gpu_data->secondary.copy_mode)
+        {
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY:
+          sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+          break;
+        case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
+          sync_fd = start_copy_shared_framebuffer_gpu (onscreen,
+                                                       secondary_gpu_state,
+                                                       renderer_gpu_data,
+                                                       region,
+                                                       error);
+          break;
+        }
+    }
+  else
+    {
+      sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+    }
+
+  return g_steal_fd (&sync_fd);
+}
+
 static MetaDrmBuffer *
 acquire_front_buffer (CoglOnscreen     *onscreen,
                       MetaFrameNative  *frame_native,
                       MetaDrmBuffer    *secondary_gpu_fb,
-                      const MtkRegion  *region,
                       GError          **error)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
@@ -1562,12 +1607,11 @@ acquire_front_buffer (CoglOnscreen     *onscreen,
         }
       return g_object_ref (secondary_gpu_fb);
     case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
-      return copy_shared_framebuffer_gpu (onscreen,
-                                          frame_native,
-                                          secondary_gpu_state,
-                                          renderer_gpu_data,
-                                          region,
-                                          error);
+      return finish_copy_shared_framebuffer_gpu (onscreen,
+                                                 frame_native,
+                                                 secondary_gpu_state,
+                                                 renderer_gpu_data,
+                                                 error);
     }
 
   g_assert_not_reached ();
@@ -1700,9 +1744,16 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                           frame_info,
                                           user_data);
 
-  sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+  sync_fd = update_state_post_swap_buffers (onscreen, region, &error);
   if (sync_fd >= 0)
-    meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+    {
+      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+    }
+  else if (error != NULL)
+    {
+      g_warning ("update_state_post_swap_buffers failed: %s", error->message);
+      goto swap_failed;
+    }
 
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
@@ -1712,7 +1763,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
       buffer = acquire_front_buffer (onscreen,
                                      frame_native,
                                      secondary_gpu_fb,
-                                     region,
                                      &error);
       if (buffer == NULL)
         {
-- 
GitLab


From 4aa20b7ead88edd40670ebac8fb709e74a68fb7d Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 7 Aug 2025 17:37:48 +0800
Subject: [PATCH 3/6] onscreen/native: Defer front buffer acquisition until
 ready to post

nvidia-drm needs this because gbm_surface_lock_front_buffer() will block
while rendering is pending. And the GBM docs don't say it needs to be
non-blocking. It would be interesting to find out if other bespoke GBM
implementations (like Xilinx) have the same issue...
---
 src/backends/native/meta-onscreen-native.c | 118 +++++++++++++--------
 1 file changed, 71 insertions(+), 47 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 30336bf582b..c4647987394 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -104,6 +104,7 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
   gboolean noted_primary_gpu_copy_ok;
   gboolean noted_primary_gpu_copy_failed;
   MetaSharedFramebufferImportStatus import_status;
+  MetaDrmBuffer *source_framebuffer;
 } MetaOnscreenNativeSecondaryGpuState;
 
 typedef struct _KmsProperty
@@ -1716,20 +1717,13 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                                CoglFrameInfo   *frame_info,
                                                gpointer         user_data)
 {
-  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
-  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
-  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
-  CoglRendererEGL *cogl_renderer_egl = cogl_renderer_get_winsys_data (cogl_renderer);
-  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
-  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-  MetaGpuKms *render_gpu = onscreen_native->render_gpu;
+  MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   CoglOnscreenClass *parent_class;
   g_autoptr (GError) error = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
-  g_autoptr (MetaDrmBuffer) buffer = NULL;
   g_autofd int sync_fd = -1;
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
@@ -1738,6 +1732,13 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   secondary_gpu_fb =
     update_secondary_gpu_state_pre_swap_buffers (onscreen, region);
 
+  secondary_gpu_state = onscreen_native->secondary_gpu_state;
+  if (secondary_gpu_state)
+    {
+      g_set_object (&secondary_gpu_state->source_framebuffer,
+                    g_steal_pointer (&secondary_gpu_fb));
+    }
+
   parent_class = COGL_ONSCREEN_CLASS (meta_onscreen_native_parent_class);
   parent_class->swap_buffers_with_damage (onscreen,
                                           region,
@@ -1755,44 +1756,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
       goto swap_failed;
     }
 
-  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
-                                                         render_gpu);
-  switch (renderer_gpu_data->mode)
-    {
-    case META_RENDERER_NATIVE_MODE_GBM:
-      buffer = acquire_front_buffer (onscreen,
-                                     frame_native,
-                                     secondary_gpu_fb,
-                                     &error);
-      if (buffer == NULL)
-        {
-          g_warning ("Failed to acquire front buffer: %s", error->message);
-          goto swap_failed;
-        }
-
-      meta_frame_native_set_buffer (frame_native, buffer);
-
-      if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
-        {
-          MetaRenderDevice *render_device =
-            renderer_gpu_data->render_device;
-          MetaDeviceFile *render_device_file =
-            meta_render_device_get_device_file (render_device);
-
-          g_warning ("Failed to ensure KMS FB ID on %s: %s",
-                     meta_device_file_get_path (render_device_file),
-                     error->message);
-          goto swap_failed;
-        }
-      break;
-    case META_RENDERER_NATIVE_MODE_SURFACELESS:
-      break;
-#ifdef HAVE_EGL_DEVICE
-    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
-      break;
-#endif
-    }
-
   assign_next_frame (onscreen_native, frame);
 
   clutter_frame_set_result (frame,
@@ -1838,8 +1801,10 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
   const MetaKmsResultListenerVtable *listener;
   MetaKmsAssignPlaneFlag flip_flags;
   gboolean is_direct_scanout;
+  gboolean is_swap_buffers;
   MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
   MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  CoglFrameInfo *frame_info;
 
   COGL_TRACE_SCOPED_ANCHOR (MetaRendererNativePostKmsUpdate);
 
@@ -1869,12 +1834,64 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
                                                     kms_device);
 
   is_direct_scanout = meta_frame_native_get_scanout (frame_native) != NULL;
+  is_swap_buffers = meta_frame_native_get_damage (frame_native) != NULL;
+
   if (is_direct_scanout)
     {
       listener = &scanout_result_listener_vtable;
       flip_flags = META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC;
     }
-  else
+  else if (is_swap_buffers)
+    {
+      g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
+      g_autoptr (MetaDrmBuffer) buffer = NULL;
+      g_autoptr (GError) error = NULL;
+      MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+      MetaDeviceFile *render_device_file =
+        meta_render_device_get_device_file (renderer_gpu_data->render_device);
+
+      listener = &swap_buffer_result_listener_vtable;
+      flip_flags = META_KMS_ASSIGN_PLANE_FLAG_NONE;
+
+      secondary_gpu_state = onscreen_native->secondary_gpu_state;
+      if (secondary_gpu_state)
+        {
+          secondary_gpu_fb =
+            g_steal_pointer (&secondary_gpu_state->source_framebuffer);
+        }
+
+      switch (renderer_gpu_data->mode)
+        {
+        case META_RENDERER_NATIVE_MODE_GBM:
+          buffer = acquire_front_buffer (onscreen,
+                                         frame_native,
+                                         secondary_gpu_fb,
+                                         &error);
+          if (buffer == NULL)
+            {
+              g_warning ("Failed to acquire front buffer: %s", error->message);
+              goto post_failed;
+            }
+
+          meta_frame_native_set_buffer (frame_native, buffer);
+
+          if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
+            {
+              g_warning ("Failed to ensure KMS FB ID on %s: %s",
+                         meta_device_file_get_path (render_device_file),
+                         error->message);
+              goto post_failed;
+            }
+          break;
+        case META_RENDERER_NATIVE_MODE_SURFACELESS:
+          break;
+#ifdef HAVE_EGL_DEVICE
+        case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
+          break;
+#endif
+        }
+    }
+  else /* property-only update, no framebuffer changes */
     {
       listener = &swap_buffer_result_listener_vtable;
       flip_flags = META_KMS_ASSIGN_PLANE_FLAG_NONE;
@@ -1969,6 +1986,13 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
 
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
+
+  return;
+
+post_failed:
+  frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
+  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
+  meta_onscreen_native_notify_frame_complete (onscreen);
 }
 
 gboolean
-- 
GitLab


From e17a26cd69282bc06e288a40b2c762a496321072 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Fri, 17 Oct 2025 13:19:30 +0800
Subject: [PATCH 4/6] backends/native: Add GPollFD functions to MetaFrameNative

---
 src/backends/native/meta-frame-native.c | 47 +++++++++++++++++++++----
 src/backends/native/meta-frame-native.h | 11 ++++++
 2 files changed, 52 insertions(+), 6 deletions(-)

diff --git a/src/backends/native/meta-frame-native.c b/src/backends/native/meta-frame-native.c
index 98cd917c737..76998638554 100644
--- a/src/backends/native/meta-frame-native.c
+++ b/src/backends/native/meta-frame-native.c
@@ -35,7 +35,8 @@ struct _MetaFrameNative
   MetaKmsUpdate *kms_update;
 
   MtkRegion *damage;
-  int sync_fd;
+
+  GPollFD sync;
 };
 
 static void
@@ -43,7 +44,7 @@ meta_frame_native_release (ClutterFrame *frame)
 {
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
 
-  g_clear_fd (&frame_native->sync_fd, NULL);
+  g_clear_fd (&frame_native->sync.fd, NULL);
   g_clear_pointer (&frame_native->damage, mtk_region_unref);
   g_clear_object (&frame_native->buffer);
   g_clear_object (&frame_native->scanout);
@@ -57,7 +58,8 @@ meta_frame_native_new (void)
   MetaFrameNative *frame_native =
     clutter_frame_new (MetaFrameNative, meta_frame_native_release);
 
-  frame_native->sync_fd = -1;
+  frame_native->sync.fd = -1;
+  frame_native->sync.events = 0;
 
   return frame_native;
 }
@@ -139,12 +141,45 @@ void
 meta_frame_native_set_sync_fd (MetaFrameNative *frame_native,
                                int              sync_fd)
 {
-  g_clear_fd (&frame_native->sync_fd, NULL);
-  frame_native->sync_fd = sync_fd;
+  g_clear_fd (&frame_native->sync.fd, NULL);
+  frame_native->sync.fd = sync_fd;
 }
 
 int
 meta_frame_native_steal_sync_fd (MetaFrameNative *frame_native)
 {
-  return g_steal_fd (&frame_native->sync_fd);
+  g_warn_if_fail (frame_native->sync.events == 0);
+
+  return g_steal_fd (&frame_native->sync.fd);
+}
+
+void
+meta_frame_native_add_source (MetaFrameNative *frame_native,
+                              GSource         *source)
+{
+  g_return_if_fail (frame_native->sync.fd >= 0);
+  g_return_if_fail (frame_native->sync.events == 0);
+
+  frame_native->sync.events = G_IO_IN;
+  g_source_add_poll (source, &frame_native->sync);
+}
+
+void
+meta_frame_native_remove_source (MetaFrameNative *frame_native,
+                                 GSource         *source)
+{
+  g_return_if_fail (frame_native->sync.fd >= 0);
+  g_return_if_fail (frame_native->sync.events != 0);
+
+  g_source_remove_poll (source, &frame_native->sync);
+  frame_native->sync.events = 0;
+}
+
+gboolean
+meta_frame_native_is_ready (MetaFrameNative *frame_native)
+{
+  g_return_val_if_fail (frame_native->sync.fd >= 0, FALSE);
+  g_return_val_if_fail (frame_native->sync.events != 0, FALSE);
+
+  return !!(frame_native->sync.revents & G_IO_IN);
 }
diff --git a/src/backends/native/meta-frame-native.h b/src/backends/native/meta-frame-native.h
index 38547ebc1c0..cf736da5f82 100644
--- a/src/backends/native/meta-frame-native.h
+++ b/src/backends/native/meta-frame-native.h
@@ -61,3 +61,14 @@ meta_frame_native_set_sync_fd (MetaFrameNative *frame_native,
 
 int
 meta_frame_native_steal_sync_fd (MetaFrameNative *frame_native);
+
+void
+meta_frame_native_add_source (MetaFrameNative *frame_native,
+                              GSource         *source);
+
+void
+meta_frame_native_remove_source (MetaFrameNative *frame_native,
+                                 GSource         *source);
+
+gboolean
+meta_frame_native_is_ready (MetaFrameNative *frame_native);
-- 
GitLab


From 1dace65d223ba6b12c451f215a9263758ed7eeb1 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 23 Oct 2025 15:53:44 +0800
Subject: [PATCH 5/6] backends/native: Rename secondary.needs_explicit_sync to
 is_nvidia

No change in functionality, but the flag will soon be used in multiple
locations, not just for controlling explicit sync.
---
 src/backends/native/meta-onscreen-native.c         | 2 +-
 src/backends/native/meta-renderer-native-private.h | 2 +-
 src/backends/native/meta-renderer-native.c         | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index c4647987394..301c2b1d4cc 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -1116,7 +1116,7 @@ start_copy_shared_framebuffer_gpu (CoglOnscreen                         *onscree
   if (!primary_gpu_fb)
     return -1;
 
-  if (renderer_gpu_data->secondary.needs_explicit_sync)
+  if (renderer_gpu_data->secondary.is_nvidia)
     sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
 
   render_device = renderer_gpu_data->render_device;
diff --git a/src/backends/native/meta-renderer-native-private.h b/src/backends/native/meta-renderer-native-private.h
index 9c7887a1efc..3f94c30809b 100644
--- a/src/backends/native/meta-renderer-native-private.h
+++ b/src/backends/native/meta-renderer-native-private.h
@@ -61,7 +61,7 @@ typedef struct _MetaRendererNativeGpuData
     MetaSharedFramebufferCopyMode copy_mode;
     gboolean copy_mode_primary_force_cpu;
     gboolean has_EGL_EXT_image_dma_buf_import_modifiers;
-    gboolean needs_explicit_sync;
+    gboolean is_nvidia;
 
     /* For GPU blit mode */
     EGLContext egl_context;
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index bd2bd262420..7288d92e7a7 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -2114,7 +2114,7 @@ init_secondary_gpu_data_gpu (MetaRendererNativeGpuData *renderer_gpu_data,
 
   egl_vendor = meta_egl_query_string (egl, egl_display, EGL_VENDOR);
   if (!g_strcmp0 (egl_vendor, "NVIDIA"))
-    renderer_gpu_data->secondary.needs_explicit_sync = TRUE;
+    renderer_gpu_data->secondary.is_nvidia = TRUE;
 
   ret = TRUE;
 out:
-- 
GitLab


From f6bb454c0da60c78169a3608a042ca2ceff2af4f Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 21 Aug 2025 17:12:50 +0800
Subject: [PATCH 6/6] onscreen/native: Add a "render source" signalling GL
 completion

For the composited path, this defers calling maybe_post_next_frame
until the GPU signals that rendering is actually finished. On nvidia-drm,
doing so avoids spending milliseconds blocked inside
`gbm_surface_lock_front_buffer` each frame. But the problem is not
provably limited to Nvidia since the GBM docs are vague enough that
we may expect the same issue in other bespoke GBM implementations.

Since Mesa DRI drivers are always non-blocking in `lock_front_buffer`,
the new path is only enabled for nvidia-drm at the moment. In theory the
DRI drivers can already achieve higher performance by not having to defer
the post in userspace. In practice we don't see any performance
difference on drivers other than Nvidia.

Mostly solves https://gitlab.gnome.org/GNOME/mutter/-/issues/3461, where
the amount of time blocked inside `gbm_surface_lock_front_buffer` has been
reduced by:
 - 99% for the single GPU case
 - 99% for the double-buffering hybrid GPU case
 - 50% for the triple-buffering hybrid GPU case (needs more work)
---
 src/backends/native/meta-onscreen-native.c | 261 ++++++++++++++++++++-
 1 file changed, 252 insertions(+), 9 deletions(-)

diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 301c2b1d4cc..024e4c9fdbd 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -107,6 +107,13 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
   MetaDrmBuffer *source_framebuffer;
 } MetaOnscreenNativeSecondaryGpuState;
 
+typedef struct _RenderSource
+{
+  GSource source;
+  MetaOnscreenNative *onscreen_native;
+  GHashTable *frames;
+} RenderSource;
+
 typedef struct _KmsProperty
 {
   gboolean invalidated;
@@ -149,6 +156,8 @@ struct _MetaOnscreenNative
 
   MetaRendererView *view;
 
+  GSource *render_source;
+
   union {
     struct {
       KmsProperty gamma_lut;
@@ -176,6 +185,194 @@ init_secondary_gpu_state (MetaRendererNative  *renderer_native,
                           CoglOnscreen        *onscreen,
                           GError             **error);
 
+static MetaEgl *
+meta_onscreen_native_get_egl (MetaOnscreenNative *onscreen_native);
+
+static void
+render_source_remove_frame (GSource      *source,
+                            ClutterFrame *frame)
+{
+  RenderSource *render_source;
+
+  if (!source || !frame)
+    return;
+
+  render_source = (RenderSource *) source;
+  if (g_hash_table_contains (render_source->frames, frame))
+    {
+      MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
+
+      meta_frame_native_remove_source (frame_native, source);
+      g_hash_table_remove (render_source->frames, frame);
+    }
+}
+
+static void
+render_source_add_frame (GSource      *source,
+                         ClutterFrame *frame)
+{
+  RenderSource *render_source;
+  MetaFrameNative *frame_native;
+
+  g_return_if_fail (source != NULL);
+  g_return_if_fail (frame != NULL);
+
+  render_source = (RenderSource *) source;
+  g_return_if_fail (!g_hash_table_contains (render_source->frames, frame));
+
+  frame_native = meta_frame_native_from_frame (frame);
+  meta_frame_native_add_source (frame_native, source);
+  g_hash_table_insert (render_source->frames, clutter_frame_ref (frame), NULL);
+}
+
+static gboolean
+render_source_ready (GSource *source)
+{
+  RenderSource *render_source = (RenderSource *) source;
+  MetaOnscreenNative *onscreen_native = render_source->onscreen_native;
+  ClutterFrame *frame = onscreen_native->next_frame;
+  MetaFrameNative *frame_native;
+
+  if (frame == NULL)
+    return FALSE;
+
+  if (!g_hash_table_contains (render_source->frames, frame))
+    return FALSE;
+
+  frame_native = meta_frame_native_from_frame (frame);
+  return meta_frame_native_is_ready (frame_native);
+}
+
+static void
+maybe_post_next_frame_if_gl_finished (CoglOnscreen *onscreen)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  RenderSource *render_source = (RenderSource *) onscreen_native->render_source;
+  ClutterFrame *frame = onscreen_native->next_frame;
+
+  if (frame == NULL)
+    return;
+
+  if (render_source &&
+      g_hash_table_contains (render_source->frames, frame) &&
+      !meta_frame_native_is_ready (meta_frame_native_from_frame (frame)))
+    {
+      return;
+    }
+
+  maybe_post_next_frame (onscreen);
+}
+
+static gboolean
+render_source_prepare (GSource *source,
+                       gint    *timeout_ms)
+{
+  *timeout_ms = -1;
+
+  return render_source_ready (source);
+}
+
+static gboolean
+render_source_check (GSource *source)
+{
+  return render_source_ready (source);
+}
+
+static gboolean
+render_source_dispatch (GSource     *source,
+                        GSourceFunc  callback,
+                        gpointer     user_data)
+{
+  if (callback)
+    callback (user_data);
+
+  return G_SOURCE_CONTINUE;
+}
+
+static void
+render_source_finalize (GSource *source)
+{
+  RenderSource *render_source = (RenderSource *) source;
+
+  g_clear_pointer (&render_source->frames, g_hash_table_destroy);
+}
+
+static void
+maybe_init_render_source (MetaOnscreenNative *onscreen_native)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen_native);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  const char *force_render_source;
+  gboolean use_render_source;
+
+  force_render_source = g_getenv ("MUTTER_DEBUG_FORCE_RENDER_SOURCE");
+  if (force_render_source != NULL)
+    {
+      use_render_source = g_strcmp0 (force_render_source, "0") != 0;
+    }
+  else
+    {
+      MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state =
+        onscreen_native->secondary_gpu_state;
+      gboolean output_gpu_is_nvidia;
+
+      if (secondary_gpu_state)
+        {
+          MetaRendererNativeGpuData *renderer_gpu_data =
+            secondary_gpu_state->renderer_gpu_data;
+
+          output_gpu_is_nvidia = renderer_gpu_data->secondary.is_nvidia;
+        }
+      else
+        {
+          MetaEgl *egl = meta_onscreen_native_get_egl (onscreen_native);
+          EGLDisplay egl_display = cogl_context_get_egl_display (cogl_context);
+          const char *egl_vendor =
+            meta_egl_query_string (egl, egl_display, EGL_VENDOR);
+          output_gpu_is_nvidia =
+            g_strcmp0 (egl_vendor, "NVIDIA") == 0;
+        }
+
+      use_render_source = output_gpu_is_nvidia;
+    }
+
+  if (use_render_source)
+    {
+      static GSourceFuncs render_source_funcs = {
+        .prepare = render_source_prepare,
+        .check = render_source_check,
+        .dispatch = render_source_dispatch,
+        .finalize = render_source_finalize,
+      };
+      GSource *source;
+      RenderSource *render_source;
+
+      if (!cogl_context_has_feature (cogl_context,
+                                     COGL_FEATURE_ID_SYNC_FD))
+        {
+          g_warning ("Render source feature was requested but is disabled "
+                     "due to lack of driver support.");
+          return;
+        }
+
+      source = g_source_new (&render_source_funcs, sizeof (RenderSource));
+      onscreen_native->render_source = source;
+      render_source = (RenderSource *) source;
+      render_source->frames = g_hash_table_new_full (g_direct_hash,
+                                                     g_direct_equal,
+                                                     (GDestroyNotify) clutter_frame_unref,
+                                                     NULL);
+      render_source->onscreen_native = onscreen_native;
+      g_source_set_name (source, "MetaOnscreenNative.render_source");
+      g_source_set_can_recurse (source, FALSE);
+      g_source_set_callback (source,
+                             (GSourceFunc) maybe_post_next_frame_if_gl_finished,
+                             onscreen_native,
+                             NULL);
+      g_source_attach (source, NULL);
+    }
+}
+
 static void
 meta_onscreen_native_promote_posted_frame (CoglOnscreen *onscreen)
 {
@@ -283,7 +480,7 @@ notify_view_crtc_presented (MetaRendererView *view,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_promote_posted_frame (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static void
@@ -340,7 +537,7 @@ page_flip_feedback_ready (MetaKmsCrtc *kms_crtc,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_promote_posted_frame (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static void
@@ -408,7 +605,7 @@ page_flip_feedback_discarded (MetaKmsCrtc  *kms_crtc,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_clear_posted_fb (onscreen);
-  maybe_post_next_frame (onscreen);
+  maybe_post_next_frame_if_gl_finished (onscreen);
 }
 
 static const MetaKmsPageFlipListenerVtable page_flip_listener_vtable = {
@@ -1691,6 +1888,8 @@ assign_next_frame (MetaOnscreenNative *onscreen_native,
 
   if (onscreen_native->next_frame != NULL)
     {
+      render_source_remove_frame (onscreen_native->render_source,
+                                  onscreen_native->next_frame);
       clear_superseded_frame (onscreen);
       onscreen_native->superseded_frame =
         g_steal_pointer (&onscreen_native->next_frame);
@@ -1729,6 +1928,34 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
                            "Meta::OnscreenNative::swap_buffers_with_damage()");
 
+  if (onscreen_native->next_frame != NULL)
+    {
+      /* This is the slow path (though still faster than what came before it)
+       * because it bypasses the render_source. It's here for two reasons:
+       *  1. Nvidia's eglSwapBuffers will deadlock unless paired perfectly
+       *     with the same number of gbm_surface_lock_front_buffer calls.
+       *     Mesa does not seem to have this issue and allows more swaps than
+       *     locks (has more buffers?).
+       *  2. AMDGPU doesn't deadlock but would result in a frame drop causing
+       *     stutter if assign_next_frame is called without allowing another
+       *     attempt at maybe_post_next_frame first.
+       *
+       * We only seem to arrive here frequently when using
+       * COPY_MODE_SECONDARY_GPU. This suggests there's a unique timing issue
+       * causing the third buffer to be scheduled too early. Though to be fair,
+       * dual-GPU render times are also longer which means the latest frame
+       * will be scheduled early in an attempt to catch up.
+       *
+       * Disabling the render source, or disabling triple buffering avoids
+       * this path, but also results in noticeably lower performance.
+       */
+      maybe_post_next_frame (onscreen);
+
+      g_warn_if_fail (onscreen_native->next_frame == NULL);
+      if (onscreen_native->next_frame != NULL)
+        goto swap_failed;
+    }
+
   secondary_gpu_fb =
     update_secondary_gpu_state_pre_swap_buffers (onscreen, region);
 
@@ -1746,11 +1973,7 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
                                           user_data);
 
   sync_fd = update_state_post_swap_buffers (onscreen, region, &error);
-  if (sync_fd >= 0)
-    {
-      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
-    }
-  else if (error != NULL)
+  if (sync_fd < 0 && error != NULL)
     {
       g_warning ("update_state_post_swap_buffers failed: %s", error->message);
       goto swap_failed;
@@ -1763,7 +1986,19 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen    *onscreen,
 
   meta_frame_native_set_damage (frame_native, region);
 
-  maybe_post_next_frame (onscreen);
+  if (sync_fd >= 0)
+    {
+      meta_frame_native_set_sync_fd (frame_native, g_steal_fd (&sync_fd));
+      if (onscreen_native->render_source)
+        render_source_add_frame (onscreen_native->render_source, frame);
+      else
+        maybe_post_next_frame (onscreen);
+    }
+  else
+    {
+      maybe_post_next_frame (onscreen);
+    }
+
   return;
 
 swap_failed:
@@ -1822,6 +2057,8 @@ maybe_post_next_frame (CoglOnscreen *onscreen)
       return;
     }
 
+  render_source_remove_frame (onscreen_native->render_source,
+                              onscreen_native->next_frame);
   frame = g_steal_pointer (&onscreen_native->next_frame);
   frame_native = meta_frame_native_from_frame (frame);
   region = meta_frame_native_get_damage (frame_native);
@@ -2449,6 +2686,9 @@ meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen)
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
   discard_pending_swap (&onscreen_native->superseded_frame);
+
+  render_source_remove_frame (onscreen_native->render_source,
+                              onscreen_native->next_frame);
   discard_pending_swap (&onscreen_native->next_frame);
 }
 
@@ -2873,6 +3113,8 @@ meta_onscreen_native_allocate (CoglFramebuffer  *framebuffer,
         return FALSE;
     }
 
+  maybe_init_render_source (onscreen_native);
+
   width = cogl_framebuffer_get_width (framebuffer);
   height = cogl_framebuffer_get_height (framebuffer);
 
@@ -3282,6 +3524,7 @@ meta_onscreen_native_dispose (GObject *object)
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
   MetaRendererNativeGpuData *renderer_gpu_data;
 
+  g_clear_pointer (&onscreen_native->render_source, g_source_destroy);
   meta_onscreen_native_detach (onscreen_native);
 
   meta_onscreen_native_discard_pending_swaps (onscreen);
-- 
GitLab
